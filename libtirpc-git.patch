commit fbe8b50728c565459f2678aa1ad4dfc6610d1f9e
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Mar 13 12:48:40 2009 -0400

    libtirpc: must free saved wire verifier when destroying context
    
    When we're destroying the authgss context, we must also free any
    saved wire verifier that we have to keep from leaking memory.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve Dickson <steved@redhat.com>

diff --git a/src/auth_gss.c b/src/auth_gss.c
index bf6cba6..df3017a 100644
--- a/src/auth_gss.c
+++ b/src/auth_gss.c
@@ -567,6 +567,12 @@ authgss_destroy_context(AUTH *auth)
 		gss_delete_sec_context(&min_stat, &gd->ctx, NULL);
 		gd->ctx = GSS_C_NO_CONTEXT;
 	}
+
+	/* free saved wire verifier (if any) */
+	mem_free(gd->gc_wire_verf.value, gd->gc_wire_verf.length);
+	gd->gc_wire_verf.value = NULL;
+	gd->gc_wire_verf.length = 0;
+
 	gd->established = FALSE;
 }
 

commit 956a049085101961593956d01084f7f713ea8ded
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Mar 13 12:47:36 2009 -0400

    libtirpc: be sure to free cl_netid and cl_tp
    
    When creating a client with clnt_tli_create, it uses strdup to copy
    strings for these fields if nconf is passed in. clnt_dg_destroy frees
    these strings already. Make sure clnt_vc_destroy frees them in the same
    way.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve Dickson <steved@redhat.com>

diff --git a/src/clnt_vc.c b/src/clnt_vc.c
index 1dcc976..eb9bb7f 100644
--- a/src/clnt_vc.c
+++ b/src/clnt_vc.c
@@ -646,6 +646,10 @@ clnt_vc_destroy(cl)
 	if (ct->ct_addr.buf)
 		free(ct->ct_addr.buf);
 	mem_free(ct, sizeof(struct ct_data));
+	if (cl->cl_netid && cl->cl_netid[0])
+		mem_free(cl->cl_netid, strlen(cl->cl_netid) +1);
+	if (cl->cl_tp && cl->cl_tp[0])
+		mem_free(cl->cl_tp, strlen(cl->cl_tp) +1);
 	mem_free(cl, sizeof(CLIENT));
 	mutex_unlock(&clnt_fd_lock);
 	thr_sigsetmask(SIG_SETMASK, &(mask), NULL);

commit 1c8c2bf2f0b81b0fa1992894679786619c048a1e
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Mar 13 12:44:16 2009 -0400

    libtirpc: set r_netid and r_owner in __rpcb_findaddr_timed
    
    These fields in the rpcbind GETADDR call are being passed uninitialized
    to CLNT_CALL. In the case of x86_64 at least, this usually leads to a
    segfault. On x86, it sometimes causes segfaults and other times causes
    garbage to be sent on the wire.
    
    rpcbind generally ignores the r_owner field for calls that come in over
    the wire, so it really doesn't matter what we send in that slot. We just
    need to send something. The reference implementation from Sun seems to
    send a blank string. Have ours follow suit.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve Dickson <steved@redhat.com>

diff --git a/src/rpcb_clnt.c b/src/rpcb_clnt.c
index ed16f00..b1c0038 100644
--- a/src/rpcb_clnt.c
+++ b/src/rpcb_clnt.c
@@ -749,6 +749,13 @@ __rpcb_findaddr_timed(program, version, nconf, host, clpp, tp)
 	parms.r_addr = NULL;
 	parms.r_prog = program;
 	parms.r_vers = version;
+	parms.r_netid = nconf->nc_netid;
+
+	/*
+	 * According to wire captures, the reference implementation
+	 * (OpenSolaris) sends a blank string here too.
+	 */
+	parms.r_owner = "";
 
 	/*
 	 * Use default total timeout if no timeout is specified.

commit 951a1b9b0195cbe58e1e62142e84d7ec4658943f
Author: Steve Dickson <steved@redhat.com>
Date:   Wed Jan 28 12:44:46 2009 -0500

    Converted all uid and gid variables of the type uid_t and gid_t.
    
    Signed-off-by: Steve Dickson <steved@redhat.com>

diff --git a/src/auth_unix.c b/src/auth_unix.c
index c2727e0..04ee5dd 100644
--- a/src/auth_unix.c
+++ b/src/auth_unix.c
@@ -84,10 +84,10 @@ struct audata {
 AUTH *
 authunix_create(machname, uid, gid, len, aup_gids)
 	char *machname;
-	int uid;
-	int gid;
+	uid_t uid;
+	gid_t gid;
 	int len;
-	int *aup_gids;
+	gid_t *aup_gids;
 {
 	struct authunix_parms aup;
 	char mymem[MAX_AUTH_BYTES];
@@ -189,8 +189,7 @@ authunix_create_default()
 	if ((len = getgroups(NGRPS, gids)) < 0)
 		abort();
 	/* XXX: interface problem; those should all have been unsigned */
-	return (authunix_create(machname, (int)uid, (int)gid, len,
-	    (int *)gids));
+	return (authunix_create(machname, uid, gid, len, gids));
 }
 
 /*
diff --git a/src/authunix_prot.c b/src/authunix_prot.c
index 01c1711..79f2fb6 100644
--- a/src/authunix_prot.c
+++ b/src/authunix_prot.c
@@ -57,8 +57,8 @@ xdr_authunix_parms(xdrs, p)
 
 	if (xdr_u_long(xdrs, &(p->aup_time))
 	    && xdr_string(xdrs, &(p->aup_machname), MAX_MACHINE_NAME)
-	    && xdr_int(xdrs, &(p->aup_uid))
-	    && xdr_int(xdrs, &(p->aup_gid))
+	    && xdr_u_int(xdrs, &(p->aup_uid))
+	    && xdr_u_int(xdrs, &(p->aup_gid))
 	    && xdr_array(xdrs, (caddr_t *)&(p->aup_gids),
 		    &(p->aup_len), NGRPS, sizeof(int), (xdrproc_t)xdr_int) ) {
 		return (TRUE);
diff --git a/src/svc_auth_unix.c b/src/svc_auth_unix.c
index 77a1272..7a7eeaa 100644
--- a/src/svc_auth_unix.c
+++ b/src/svc_auth_unix.c
@@ -59,7 +59,7 @@ _svcauth_unix(rqst, msg)
 	struct area {
 		struct authunix_parms area_aup;
 		char area_machname[MAX_MACHINE_NAME+1];
-		int area_gids[NGRPS];
+		gid_t area_gids[NGRPS];
 	} *area;
 	u_int auth_len;
 	size_t str_len, gid_len;
diff --git a/tirpc/rpc/auth.h b/tirpc/rpc/auth.h
index c6c418c..532a8cb 100644
--- a/tirpc/rpc/auth.h
+++ b/tirpc/rpc/auth.h
@@ -279,8 +279,7 @@ int authany_wrap(void), authany_unwrap(void);
  *	int *aup_gids;
  */
 __BEGIN_DECLS
-extern AUTH *authunix_create(char *, int, int, int,
-    int *);
+extern AUTH *authunix_create(char *, uid_t, uid_t, int, uid_t *);
 extern AUTH *authunix_create_default(void);	/* takes no parameters */
 extern AUTH *authnone_create(void);		/* takes no parameters */
 __END_DECLS
diff --git a/tirpc/rpc/auth_unix.h b/tirpc/rpc/auth_unix.h
index 41f0f44..0839fb3 100644
--- a/tirpc/rpc/auth_unix.h
+++ b/tirpc/rpc/auth_unix.h
@@ -60,10 +60,10 @@
 struct authunix_parms {
 	u_long	 aup_time;
 	char	*aup_machname;
-	int	 aup_uid;
-	int	 aup_gid;
+	uid_t 	 aup_uid;
+	gid_t  	 aup_gid;
 	u_int	 aup_len;
-	int	*aup_gids;
+	gid_t 	*aup_gids;
 };
 
 #define authsys_parms authunix_parms

commit 5bc80ccd81e0c7ef185de34e7f34a7766bce0e27
Author: Steve Dickson <steved@redhat.com>
Date:   Wed Jan 28 09:56:10 2009 -0500

    Removed a number warnings by adding a number of type casts.
    
    Signed-off-by: Steve Dickson <steved@redhat.com>

diff --git a/src/auth_gss.c b/src/auth_gss.c
index 8f7919c..bf6cba6 100644
--- a/src/auth_gss.c
+++ b/src/auth_gss.c
@@ -221,7 +221,7 @@ authgss_create_default(CLIENT *clnt, char *service, struct rpc_gss_sec *sec)
 	sname.length = strlen(service);
 
 	maj_stat = gss_import_name(&min_stat, &sname,
-		GSS_C_NT_HOSTBASED_SERVICE,
+		(gss_OID)GSS_C_NT_HOSTBASED_SERVICE,
 		&name);
 
 	if (maj_stat != GSS_S_COMPLETE) {
diff --git a/src/authgss_prot.c b/src/authgss_prot.c
index 97724f1..be0d1a6 100644
--- a/src/authgss_prot.c
+++ b/src/authgss_prot.c
@@ -176,10 +176,11 @@ xdr_rpc_gss_unwrap_data(XDR *xdrs, xdrproc_t xdr_func, caddr_t xdr_ptr,
 	XDR		tmpxdrs;
 	gss_buffer_desc	databuf, wrapbuf;
 	OM_uint32	maj_stat, min_stat;
-	u_int		seq_num, conf_state, qop_state;
+	u_int		seq_num, qop_state;
+	int			conf_state;
 	bool_t		xdr_stat;
 
-	if (xdr_func == xdr_void || xdr_ptr == NULL)
+	if (xdr_func == (xdrproc_t)xdr_void || xdr_ptr == NULL)
 		return (TRUE);
 
 	memset(&databuf, 0, sizeof(databuf));
diff --git a/src/svc_auth_gss.c b/src/svc_auth_gss.c
index 346e5b1..9e9ff81 100644
--- a/src/svc_auth_gss.c
+++ b/src/svc_auth_gss.c
@@ -190,7 +190,7 @@ svcauth_gss_accept_sec_context(struct svc_req *rqst,
 	/* Deserialize arguments. */
 	memset(&recv_tok, 0, sizeof(recv_tok));
 
-	if (!svc_getargs(rqst->rq_xprt, xdr_rpc_gss_init_args,
+	if (!svc_getargs(rqst->rq_xprt, (xdrproc_t)xdr_rpc_gss_init_args,
 			 (caddr_t)&recv_tok))
 		return (FALSE);
 
@@ -469,8 +469,8 @@ _svcauth_gss(struct svc_req *rqst, struct rpc_msg *msg, bool_t *no_dispatch)
 
 		*no_dispatch = TRUE;
 
-		call_stat = svc_sendreply(rqst->rq_xprt, xdr_rpc_gss_init_res,
-					  (caddr_t)&gr);
+		call_stat = svc_sendreply(rqst->rq_xprt, 
+			(xdrproc_t)xdr_rpc_gss_init_res, (caddr_t)&gr);
 
 		if (!call_stat)
 			return (AUTH_FAILED);

commit 2bb4c8d7ec8a98e1be9133d5901149a81ea9b5d9
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Wed Jan 28 09:19:07 2009 -0500

    backwards compatibility: fix order of fields in TI-RPC's svc_req
    
    Preserve ABI compatibility between glibc's RPC implementation and
    the legacy RPC implementation in libtirpc by moving the rq_xprt
    field in the TI-RPC version of the svc_req struct so it is
    backwards compatible with the legacy version of this structure.
    
    Linux's legacy svc_req struct, from /usr/include/rpc/svc.h, looks
    like this:
    
    struct svc_req {
      rpcprog_t rq_prog;		/* service program number */
      rpcvers_t rq_vers;		/* service protocol version */
      rpcproc_t rq_proc;		/* the desired procedure */
      struct opaque_auth rq_cred;	/* raw creds from the wire */
      caddr_t rq_clntcred;		/* read only cooked cred */
      SVCXPRT *rq_xprt;		/* associated transport */
    };
    
    The new TI-RPC svc_req struct, from /usr/include/tirpc/rpc/svc.h,
    looks like this:
    
    struct svc_req {
      u_int32_t rq_prog;		/* service program number */
      u_int32_t rq_vers;		/* service protocol version */
      u_int32_t rq_proc;		/* the desired procedure */
      struct opaque_auth rq_cred;	/* raw creds from the wire */
      void *rq_clntcred;		/* read only cooked cred */
      caddr_t rq_clntname;		/* read only client name */
      caddr_t rq_svcname;		/* read only cooked service cred */
      SVCXPRT *rq_xprt;		/* associated transport */
    };
    
    Note the extra fields rq_clntname and rq_svcname.  These are used for
    TI-RPC's RPCSEC GSS flavor support.
    
    This issue came to light because rpc.statd still uses only legacy RPC
    calls, and thus includes /usr/include/rpc/svc.h.  However, other parts
    of nfs-utils now link with TI-RPC, so the legacy RPC functions in
    libtirpc are used in favor of glibc's RPC functions.  The libtirpc svc
    functions use the new svc_req struct, but rpc.statd uses the old
    svc_req struct.
    
    Since the svc_req fields were different, rpc.statd broke after recent
    IPv6-related changes, even though I hadn't made any changes to it.
    Note that rpc.mountd also references the rq_xprt field, so it has the
    same issue.
    
    In most operating systems, there is only one rpc/svc.h and one version
    of svc_req so this is not a problem.  We should audit all of the
    structures and functions under /usr/include/rpc and
    /usr/include/tirpc/rpc to ensure we have a reasonable level of
    backwards compatibility until such a time it is decided to merge these
    implementations or get rid of RPC support in glibc.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Steve Dickson <steved@redhat.com>

diff --git a/tirpc/rpc/svc.h b/tirpc/rpc/svc.h
index ec5914f..ea2985d 100644
--- a/tirpc/rpc/svc.h
+++ b/tirpc/rpc/svc.h
@@ -131,14 +131,17 @@ typedef struct __rpc_svcxprt {
  * Service request
  */
 struct svc_req {
+	/* ORDER: compatibility with legacy RPC */
 	u_int32_t	rq_prog;	/* service program number */
 	u_int32_t	rq_vers;	/* service protocol version */
 	u_int32_t	rq_proc;	/* the desired procedure */
 	struct opaque_auth rq_cred;	/* raw creds from the wire */
 	void		*rq_clntcred;	/* read only cooked cred */
+	SVCXPRT		*rq_xprt;	/* associated transport */
+
+	/* New with TI-RPC */
 	caddr_t		rq_clntname;	/* read only client name */
 	caddr_t		rq_svcname;	/* read only cooked service cred */
-	SVCXPRT		*rq_xprt;	/* associated transport */
 };
 
 /*

commit 12129663ddc356aed44434aeda28ff1ce2dfc786
Author: Sandeep Josh <sdjres@yahoo.com>
Date:   Thu Jan 22 12:34:19 2009 -0500

    tirpc header file fixes for C++
    
    Added a __THROW to a couple extern declarations.
    
    Signed-off-by: Steve Dickson <steved@redhat.com>

diff --git a/tirpc/rpc/rpc.h b/tirpc/rpc/rpc.h
index 23e3197..f93479e 100644
--- a/tirpc/rpc/rpc.h
+++ b/tirpc/rpc/rpc.h
@@ -83,7 +83,7 @@
 
 __BEGIN_DECLS
 extern int get_myaddress(struct sockaddr_in *);
-extern int bindresvport(int, struct sockaddr_in *);
+extern int bindresvport(int, struct sockaddr_in *) __THROW;
 extern int registerrpc(int, int, int, char *(*)(char [UDPMSGSIZE]),
     xdrproc_t, xdrproc_t);
 extern int callrpc(const char *, int, int, int, xdrproc_t, void *,
diff --git a/tirpc/rpc/rpcent.h b/tirpc/rpc/rpcent.h
index eff86aa..1cee74c 100644
--- a/tirpc/rpc/rpcent.h
+++ b/tirpc/rpc/rpcent.h
@@ -62,8 +62,8 @@ __BEGIN_DECLS
 //extern struct rpcent *getrpcbyname(char *);
 //extern struct rpcent *getrpcbynumber(int);
 //extern struct rpcent *getrpcent(void);
-extern void setrpcent(int);
-extern void endrpcent(void);
+extern void setrpcent(int) __THROW;
+extern void endrpcent(void) __THROW;
 __END_DECLS
 
 #endif /* !_RPC_CENT_H */

commit e145633cf10c92aa6f24b8a1a322435b4e874b02
Author: Steve Dickson <steved@redhat.com>
Date:   Thu Nov 20 08:55:31 2008 -0500

    Changed clnt_spcreateerror() to return clearer
    and more concise error messages.
    
    Signed-off-by: Steve Dickson <steved@redhat.com>

diff --git a/src/clnt_perror.c b/src/clnt_perror.c
index 8f53f8e..1c1c705 100644
--- a/src/clnt_perror.c
+++ b/src/clnt_perror.c
@@ -239,7 +239,7 @@ char *
 clnt_spcreateerror(s)
 	const char *s;
 {
-	char *str;
+	char *str, *err;
 	size_t len, i;
 
 	if (s == NULL)
@@ -257,8 +257,21 @@ clnt_spcreateerror(s)
 	switch (rpc_createerr.cf_stat) {
 	case RPC_PMAPFAILURE:
 		(void) strncat(str, " - ", len - 1);
-		(void) strncat(str,
-		    clnt_sperrno(rpc_createerr.cf_error.re_status), len - 4);
+		 err = clnt_sperrno(rpc_createerr.cf_error.re_status);
+		if (err)
+			(void) strncat(str, err+5, len-5);
+		switch(rpc_createerr.cf_error.re_status) {
+		case RPC_CANTSEND:
+		case RPC_CANTRECV:
+			i = strlen(str);
+			len -= i;
+			snprintf(str+i, len, ": errno %d (%s)", 
+				rpc_createerr.cf_error.re_errno,
+				strerror(rpc_createerr.cf_error.re_errno)); 
+			break;
+		default:
+			break;
+		}
 		break;
 
 	case RPC_SYSTEMERROR:

commit 7c78a0362fcd3e0749330f11d0fdecb62131a6a3
Author: Steve Dickson <steved@redhat.com>
Date:   Thu Nov 20 08:53:52 2008 -0500

    The clnt_fd_lock mutex lock was not being
    released during an error path in clnt_dg_call.
    
    Signed-off-by: Steve Dickson <steved@redhat.com>

diff --git a/src/clnt_dg.c b/src/clnt_dg.c
index da01c5b..9a574eb 100644
--- a/src/clnt_dg.c
+++ b/src/clnt_dg.c
@@ -402,6 +402,7 @@ get_reply:
 
         fd.fd = cu->cu_fd;
         fd.events = POLLIN;
+        fd.revents = 0;
 	while (total_time > 0) {
 		tv = total_time < nextsend_time ? total_time : nextsend_time;
                 switch (poll(&fd, 1, tv)) {
@@ -455,6 +456,7 @@ get_reply:
 		{
 		  e = (struct sock_extended_err *) CMSG_DATA(cmsg);
 		  cu->cu_error.re_errno = e->ee_errno;
+		  release_fd_lock(cu->cu_fd, mask);
 		  return (cu->cu_error.re_status = RPC_CANTRECV);
 		}
 	}
